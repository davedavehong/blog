# 一个看似简单的列表页面的迭代改造

## 需求介绍

一个APP，总会有个「我的」的tab，聚合了针对用户相关的入口。这种页面说简单也简单，不就是渲染一个固定的入口嘛。但在业务开发中，就是这么看似简单的业务场景，在叠加了多个业务需求之后，也就变得没那么简单了。先看图：

![wx20180902-231914](https://user-images.githubusercontent.com/10491999/44957649-b66c1000-af06-11e8-93e0-cdaa882788ef.png)

就这么一个页面，如果要预估开发时间，估计说半天都不太好意思。但是真实的需求可没有渲染这几个列表那么简单。

提一下技术栈。页面基于React native开发，使用了React native提供的缓存方式，Redux管理数据源。

## 需求评估

- 页面满足动态性，通过API返回的数据来动态开关对应的item。
- item右侧的文案例如「我的卡包」项右侧的数字、「邀请好友」项右侧的文案，注意，文案的样式（目前）有两种。
- 红点的显示逻辑，其中「检查更新」项的红点来自于native层，我的福利的红点逻辑来自API。
- item点击事件也是各种各样，有打开URL，有通知native操作，也有路由跳转。
- 尽量不要牺牲用户一眼。


### 一期方案

View层写死每个item，每次的action之后将新数据同步到指定的props。

比较low，那时候也是先上线再说。不展开讲了。

### 二期方案

按照数据存储在store、数据处理在reducer层的思路，将整个列表的展示，抽象为二维数组，在第二层数组中添加对象表示每一个item，对象中有id作为唯一标示，有status作为显示控制的状态，还有图片、文案、点击事件。对这个页面的store数据进行缓存，防止用户每次冷启动进入页面后都会出现视觉抖动。

其中图片字段一开始是在reducer层require进来，那样就有一个问题。require产生的是一个数字，我们是缓存优先机制，用户下次进来时用的是上个版本的store数据，但在新版本安装过程中，图片产生的序列值已经产生变化，上个版本的图片值对应的已经不是这张图片，所以这个图片的地址，不能放在reducer层进行引入，而是在View层重新映射，使得图片地址保持最新。

还有点击事件，点击事件非常多样，有内部通信协议、有打开H5、也有内部路由跳转，涉及到多个props或者二方库，都堆在reducer层也不太现实，因此在reducer层只保留了点击事件的函数名字，在View层对点击事件再做分发。

对于不同样式的右侧文案，使用两种字段。

状态更新需要遍历二维数组，为了能批量更新，可以传入一个深层对象。也就是需要在reducer中做三层遍历。

同时考虑缓存兼容问题，例如新版本需要加入几项item，那么就需要在页面初始化时，对比reducer的init数据和缓存数据，但也不能全体对比，只需要对比所有位置的id是否完全一致，如果不一致，就进行全量的替换。不做这种处理的话，会导致老版本用户一上来就是缓存，不存在这个id，那么就永远无法显示新增加的item。

同时还有个动态化造成的ui上的极端case问题，因为item如果需要关闭，也只是逻辑关闭，不可能从store中移除数据。那极端case下，第一层数据中的某一个数组中，所有item都为隐藏的话，那么这一组都不展示，但是render的时候，会造成那一组最下面的下边距也会出来。所以在`mapStateToProps`的过程中，还需要一次数据清洗，就是将item全是关闭的那个数组移除掉，那么render的时候就不会出现边距了，因为都没有这一项。

好处就是增强了动态化能力。最近又一次因为一些不可描述的原因，需要紧急隐藏之前没做控制的某个入口。那么紧急发版和热更都是很难做到的，但是可以通过服务端下发指定id的显示状态就可以立即关掉了，也就是在原来控制显示状态的API的返回数据中增加一个字段。

### 三期方案（规划）

二维数组想要压缩为一维数组，那么每组之间的视觉分隔就面临两种选择，一种是在每组最后一个item标记字段，展示下边距，一种是将每组之间的ui间距当做独立的item，用专门的id区分出来。

对方案一来说，如果每组的最后一个item需要隐藏，那么在数据render之前的清洗时，就需要将展示下边距的字段移动到上个item中，如果考虑一组都隐藏的话，那么还需要将这个字段移除，对数据处理有点麻烦，代码可读性差。

方案二，因为列表渲染需要指定唯一key，同一个key的item不会展示，因此作为分隔符的item的id不能相同，而是使用关键词加序号的方式，比如divide-1、divide-2，item渲染时识别到divide关键词就去渲染一个外边距的ui块。那么这种方式下的数据处理其实和二维数组类似，在移除隐藏的元素之后，再移除相邻的分隔符的item。

二维数组压缩为一维数组的好处，是减少不必要的遍历。reducer层因为要批量更新，本身就要做一次遍历，加上二维数组的两层遍历，相当于三层遍历。而在render层也有二层遍历，而对于二维数组的第一层遍历是没有必要的，因为是没有业务逻辑的。

### 注意点

- render前的数据清洗，要注意不要污染原先数据，那么就要使用数组中返回新数组的数组方法，比如map，或者使用immutable。
- 对reducer中init数据做变动时，都要考虑之前版本缓存的兼容问题。

